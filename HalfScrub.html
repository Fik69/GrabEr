<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Frame Extractor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        /* Base styles for the body */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a;
            color: #fafafa;
            overflow-x: hidden; /* Prevent horizontal scrolling on the body */
            padding-bottom: 80px; /* Space for the fixed footer */
        }
        /* Container to manage overall scrolling */
        .scrollable-container {
            width: 100vw; /* Full viewport width */
            overflow-x: hidden; /* Prevent horizontal scrolling */
            overflow-y: auto; /* Allow vertical scrolling */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        }
        /* Styling for violet-colored buttons - Added transparency */
        .violetBtn {
            background-color: rgba(139, 92, 246, 0.9); /* Original: #8B5CF6 */
            transition: background-color 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border-radius: 6px;
        }
        .violetBtn:hover {
            background-color: #7C3AED;
        }
        .violetBtn:focus {
            outline: 2px solid #5B21B6;
            outline-offset: 2px;
        }
        /* Utility class to prevent text selection */
        .prevent-selection {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        /* Wrapper for the half-moon dial effect */
        .half-moon-wrapper {
            position: relative;
            width: 300px; /* Same width as your dial-container */
            height: 140px; /* Roughly half the height of your dial-container (280px / 2) */
            overflow: hidden;
            border-radius: 140px 140px 0 0; /* Creates the rounded top edge for the half-moon */
            background-color: #E7CEFD; /* Matches your dial-background color */
            margin-left: auto; /* Center the wrapper */
            margin-right: auto; /* Center the wrapper */
        }

        /* Container for the rotatable dial itself */
        .dial-container {
            position: absolute; /* Crucial for positioning inside .half-moon-wrapper */
            top: 0; /* Align the top of the dial with the top of the wrapper */
            left: 0;
            width: 300px; /* Keep its original dimensions */
            height: 300px; /* Keep its original dimensions */
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: none; /* Prevents default touch actions like scrolling */
            cursor: grab;
        }
        /* Background for the dial */
        .dial-background {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-color: #E7CEFD;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15);
        }
        /* The rotatable part of the dial */
        .dial-rotatable {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.05s ease-out; /* Smooth rotation transition */
        }
        /* Individual strips within the dial */
        .dial-strip {
            position: absolute;
            width: 3px;
            height: 30px;
            background-color: #350062;
            border-radius: 1px;
            top: 0;
            left: 50%;
        }
        /* Removed .dial-cue and @keyframes pulse-cue as requested */

        /* Styling for the capture frame button */
        .capture-button {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background-color: #eee;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 2px solid #810AE6;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            animation: pulse 1.5s infinite; /* Pulsing animation */
            position: relative; /* Keep this for z-index */
            z-index: 2; /* Ensure it's above the dial-rotatable and strips */
        }
        .capture-button:hover {
            background-color: #fff;
            transform: scale(1.05);
            animation: none; /* Disable pulse on hover */
        }
        .capture-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            animation: none; /* Disable pulse when disabled */
        }
        /* Styling for the camera icon within the capture button */
        .camera-icon {
            fill: #350062;
            width: 35px;
            height: 35px;
        }
        /* Keyframes for the button pulse animation */
        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.7); }
            70% { transform: scale(1); box-shadow: 0 0 0 10px rgba(139, 92, 246, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(139, 92, 246, 0); }
        }
        /* Styling for selected extracted frames */
        .extracted-frame.selected {
            border: 3px solid #8B5CF6;
        }

        /* Timeline scrubber container styles */
        .timeline-container {
            position: relative;
            width: 100%;
            height: 42px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
            padding: 0;
            margin-top: 5px;
        }
        /* Styling for the timeline scrubber itself, enabling horizontal scrolling */
        .timeline-scrubber {
            display: flex;
            overflow-x: auto;
            height: 100%;
            scrollbar-width: thin; /* Firefox */
            scrollbar-color: #8B5CF6 #2d2d2d; /* Firefox */
            padding: 0;
            gap: 0;
            scroll-behavior: smooth; /* Smooth scrolling */
        }
        /* Webkit (Chrome, Safari) scrollbar styles */
        .timeline-scrubber::-webkit-scrollbar {
            height: 8px;
        }
        .timeline-scrubber::-webkit-scrollbar-track {
            background: #2d2d2d;
            border-radius: 8px;
        }
        .timeline-scrubber::-webkit-scrollbar-thumb {
            background: #8B5CF6;
            border-radius: 8px;
        }
        /* Individual thumbnail within the timeline */
        .timeline-thumb {
            flex-shrink: 0; /* Prevents shrinking */
            width: 48px;
            height: 100%;
            border-radius: 0;
            overflow: hidden;
            position: relative;
            cursor: pointer;
            transition: transform 0.2s ease;
            box-shadow: none;
        }
        .timeline-thumb:hover {
            transform: scale(1.05); /* Slight scale on hover */
        }
        .timeline-thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .timeline-thumb .time-label {
            display: none; /* Time label is not shown on thumbnails directly */
        }
        /* Highlight for the current thumbnail */
        .current-thumb {
            border: 3px solid #F5A020;
            box-shadow: 0 0 10px rgba(245, 160, 32, 0.5);
        }
        /* Indicator for the current time on the timeline */
        .timeline-indicator {
            position: absolute;
            top: -15px;
            height: 60px;
            width: 3px;
            background: #F5A020;
            z-index: 10;
            left: 50%;
            transform: translateX(-50%);
        }
        .timeline-indicator::before {
            content: '';
            position: absolute;
            top: -10px;
            left: -7px;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 10px solid #F5A020;
        }
        /* Loading indicator for timeline generation */
        .loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 14px;
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 20px;
        }
        /* Current time label above the timeline */
        .timeline-current-time-label {
            position: absolute;
            top: -42px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #F5A020;
            border-radius: 15px;
            padding: 4px 10px;
            color: white;
            font-size: 12px;
            font-weight: 600;
            white-space: nowrap;
            z-index: 10;
        }
        /* Total frames label on the timeline */
        .timeline-total-frames-label {
            position: absolute;
            top: 50%;
            right: 10px;
            transform: translateY(-50%);
            background-color: #DDA0DD;
            border-radius: 15px;
            padding: 4px 10px;
            color: #5B21B6;
            font-size: 12px;
            font-weight: 600;
            white-space: nowrap;
            z-index: 10;
        }

        /* Aspect ratio fix for video and canvas */
        .video-container {
            position: relative;
            width: 100%;
            height: 0;
            padding-bottom: 56.25%; /* 16:9 aspect ratio */
            background-color: black;
            border-radius: 0.5rem;
            overflow: hidden;
        }
        .video-container video,
        .video-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain; /* Keeps video contained within the preview area */
        }
        .video-container canvas {
            z-index: 2;
        }
        /* Extracted frame general styling */
        .extracted-frame {
            position: relative;
            border-radius: 0.375rem; /* rounded-md */
            overflow: hidden;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* shadow-md */
            transition: transform 0.2s ease, border 0.2s ease; /* Added border transition */
            cursor: pointer;
        }

        /* --- MODIFIED: Remove button styles --- */
        .extracted-frame .remove-button {
            position: absolute;
            top: 4px; /* Slightly more padding from top */
            right: 4px; /* Slightly more padding from right */
            background-color: rgba(239, 68, 68, 0.7); /* Red-500 with transparency (70%) */
            color: white;
            border-radius: 4px; /* Square corners */
            width: 32px; /* Larger width */
            height: 32px; /* Larger height (square) */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem; /* Larger 'x' */
            font-weight: bold;
            opacity: 0; /* Hidden by default */
            transition: opacity 0.1s ease-in-out; /* Instant transition for hover/touch */
            cursor: pointer;
            z-index: 10; /* Ensure it's above other elements in the frame */
        }
        /* Show instantly on hover for desktop */
        .extracted-frame:hover .remove-button {
            opacity: 1;
        }
        /* Show instantly when the frame is "selected" (e.g., on mobile touch) */
        .extracted-frame.selected .remove-button {
            opacity: 1;
        }
        /* --- END MODIFIED --- */

        /* Footer styles - Increased transparency */
        .sticky-footer {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: rgba(45, 45, 45, 0.7); /* More transparent */
            padding: 0.5rem 1rem; /* Thinner padding */
            box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.2);
            z-index: 50; /* Ensure it's above other content */
            backdrop-filter: blur(5px); /* Frosted glass effect */
        }
        /* Style for dropdowns within the footer - Added transparency */
        .sticky-footer select {
            background-color: rgba(63, 63, 70, 0.9); /* Tailwind gray-700 equivalent with transparency */
            color: #fafafa;
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem; /* rounded-md */
            font-size: 0.875rem; /* text-sm */
            font-weight: 500; /* font-medium */
            border: none;
            outline: none;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            -webkit-appearance: none; /* Remove default arrow on Webkit */
            -moz-appearance: none;    /* Remove default arrow on Firefox */
            appearance: none;         /* Remove default arrow */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='white'%3E%3Cpath fill-rule='evenodd' d='M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z' clip-rule='evenodd'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 1.5em;
            padding-right: 2.5rem; /* Make space for the custom arrow */
        }
        .sticky-footer select:hover {
            background-color: #52525b; /* Tailwind gray-600 equivalent */
        }

    </style>
</head>
<body class="min-h-screen flex flex-col justify-between">
    <div class="scrollable-container">
        <main class="relative min-h-screen flex flex-col">
            <div class="flex flex-col flex-grow items-center justify-center pt-2 pb-4">
                <div id="upload-section" class="flex flex-col items-center gap-y-6 w-full max-w-lg text-center">
                    <svg width="55" height="60" viewBox="0 0 55 60" fill="none" xmlns="http://www.w3.org/2000/svg" class="opacity-30">
                        <path fill-rule="evenodd" clip-rule="evenodd" d="M30.25 2.72727C30.25 1.22104 29.0188 0 27.5 0C25.9812 0 24.75 1.22104 24.75 2.72727V34.3249L18.4445 28.0715C17.3706 27.0065 15.6294 27.0065 14.5555 28.0715C13.4815 29.1366 13.4815 30.8634 14.5555 31.9285L25.5535 42.8356C25.5601 42.8422 25.5668 42.8488 25.5735 42.8553C25.8329 43.108 26.1304 43.2994 26.4473 43.4294C26.7692 43.5618 27.1219 43.6353 27.4918 43.6364C27.4945 43.6364 27.4972 43.6364 27.5 43.6364C27.5028 43.6364 27.5055 43.6364 27.5082 43.6364C28.2552 43.6342 28.9322 43.3366 29.4265 42.8553C29.4332 42.8488 29.4399 42.8422 29.4465 42.8356L40.4445 31.9285C41.5185 30.8634 41.5185 29.1366 40.4445 28.0715C39.3706 27.0065 37.6294 27.0065 36.5555 28.0715L30.25 34.3249V2.72727ZM2.75 40.9091C4.26878 40.9091 5.5 42.1301 5.5 43.6364V51.8182C5.5 52.5415 5.78973 53.2352 6.30546 53.7467C6.82118 54.2581 7.52066 54.5455 8.25 54.5455H46.75C47.4793 54.5455 48.1788 54.2581 48.6945 53.7467C49.2103 53.2352 49.5 52.5415 49.5 51.8182V43.6364C49.5 42.1301 50.7312 40.9091 52.25 40.9091C53.7688 40.9091 55 42.1301 55 43.6364V51.8182C55 53.9881 54.1308 56.0692 52.5836 57.6036C51.0365 59.138 48.938 60 46.75 60H8.25C6.06196 60 3.96354 59.138 2.41637 57.6036C0.869194 56.0692 0 53.9881 0 51.8182V43.6364C0 42.1301 1.23122 40.9091 2.75 40.9091Z" fill="white"></path>
                    </svg>
                    <span class="text-sm opacity-70">Select or drag and drop a video to start extracting frames.<br/><b>100% Secure & Private.</b> Your Videos Never Leave Your PC</span>
                    <div class="relative inline-flex justify-center items-center">
                        <input type="file" class="absolute w-full h-full opacity-0 cursor-pointer z-10" id="video-input" accept="video/*"/>
                        <label for="video-input" class="violetBtn flex justify-center items-center px-6 py-3 rounded-md text-white text-sm leading-tight shadow-md">
                            <span>
                                <svg width="20" height="22" viewBox="0 0 20 22" fill="none" xmlns="http://www.w3.org/2000/svg" class="mr-3 sm:hidden">
                                    <path fill-rule="evenodd" clip-rule="evenodd" d="M11 1C11 0.447715 10.5523 0 10 0C9.44771 0 9 0.447715 9 1V12.5858L6.70711 10.2929C6.31658 9.90237 5.68342 9.90237 5.29289 10.2929C4.90237 10.6834 4.90237 11.3166 5.29289 11.7071L9.29218 15.7064C9.29459 15.7088 9.29702 15.7112 9.29945 15.7136C9.3938 15.8063 9.50195 15.8764 9.61722 15.9241C9.73425 15.9727 9.8625 15.9996 9.997 16C9.998 16 9.999 16 10 16C10.001 16 10.002 16 10.003 16C10.2746 15.9992 10.5208 15.8901 10.7005 15.7136C10.703 15.7112 10.7054 15.7088 10.7078 15.7064L14.7071 11.7071C15.0976 11.3166 15.0976 10.6834 14.7071 10.2929C14.3166 9.90237 13.6834 9.90237 13.2929 10.2929L11 12.5858V1ZM1 15C1.55228 15 2 15.4477 2 16V19C2 19.2652 2.10536 19.5196 2.29289 19.7071C2.48043 19.8946 2.73478 20 3 20H17C17.2652 20 17.5196 19.8946 17.7071 19.7071C17.8946 19.8946 18 19.2652 18 19V16C18 15.4477 18.4477 15 19 15C19.5523 15 20 15.4477 20 16V19C20 19.7957 19.6839 20.5587 19.1213 21.1213C18.5587 21.6839 17.7957 22 17 22H3C2.20435 22 1.44129 21.6839 0.87868 21.1213C0.31607 20.5587 0 19.7957 0 19V16C0 15.4477 0.447715 15 1 15Z" fill="white"></path>
                                </svg>
                            </span>Choose Video
                        </label>
                    </div>
                </div>

                <div id="video-area" class="hidden flex-col items-center justify-center w-[768px] relative mt-2 mb-0">
                    <div class="video-container">
                        <video id="video-player" class="w-full h-full"></video>
                        <canvas id="video-canvas" class="hidden"></canvas>
                    </div>
                </div>

                <div id="controls-section" class="hidden flex-col items-center w-full max-w-4xl">
                    <div class="timeline-container">
                        <div class="timeline-current-time-label" id="timeline-current-time">0:00.000f</div>
                        <div class="timeline-indicator"></div>
                        <div id="timeline-scrubber" class="timeline-scrubber"></div>
                        <div id="timeline-loading" class="loading-indicator hidden">
                            Generating timeline preview...
                        </div>
                        <div class="timeline-total-frames-label" id="timeline-total-frames">0 Frames</div>
                    </div>

                    <div class="flex flex-col sm:flex-row justify-center items-center gap-4 sm:gap-8 mt-4">
                        <div class="half-moon-wrapper">
                            <div class="dial-container" id="dial-container-wrapper">
                                <div class="dial-background"></div>
                                <div class="dial-rotatable" id="dial-rotatable">
                                    </div>
                                <button id="capture-frame-btn" class="capture-button">
                                    <svg class="camera-icon" width="30" height="30" viewBox="0 0 30 30" fill="currentColor">
                                        <path d="M22.5 17.5C22.5 19.1568 21.1568 20.5 19.5 20.5C17.8432 20.5 16.5 19.1568 16.5 17.5C16.5 15.8432 17.8432 14.5 19.5 14.5C21.1568 14.5 22.5 15.8432 22.5 17.5Z"/>
                                        <path d="M28.5 7.5H25.5L22.5 3H16.5L13.5 7.5H1.5C0.671573 7.5 0 8.17157 0 9V22.5C0 23.3284 0.671573 24 1.5 24H28.5C29.3284 24 30 23.3284 30 22.5V9C30 8.17157 29.3284 7.5 28.5 7.5ZM19.5 21C16.4624 21 14 18.5376 14 15.5C14 12.4624 16.4624 10 19.5 10C22.5376 10 25 12.4624 25 18.5376 22.5376 21 19.5 21Z"/>
                                    </svg>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="extracted-frames-section" class="hidden flex-col items-center w-full max-w-4xl bg-gray-800 rounded-lg mt-[5px] pt-4 pb-4 border-t-4 border-violet-600">
                    <button id="select-all-btn" class="violetBtn px-4 py-2 mb-4 rounded-md text-white text-sm font-semibold shadow-md">
                        Select All
                    </button>
                    <div id="extracted-frames-container" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 w-full px-4"></div>
                </div>
            </div>
        </main>
    </div>

    <footer id="download-footer" class="sticky-footer flex justify-center items-center gap-4">
        <button id="main-download-btn" class="violetBtn flex-grow px-6 py-3 rounded-md text-white text-base font-semibold shadow-md disabled:opacity-50 disabled:cursor-not-allowed flex flex-col items-center justify-center">
            <div class="flex items-center">
                <svg class="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
                <span>Download</span>
            </div>
            <span id="download-count" class="text-xs mt-1"></span>
        </button>

        <div class="flex items-center gap-2">
            <select id="scope-select" class="bg-gray-700 text-white p-2 rounded-md text-sm">
                <option value="all">All Frames</option>
                <option value="selected">Selected</option>
            </select>
            <select id="format-select" class="bg-gray-700 text-white p-2 rounded-md text-sm">
                <option value="zip">ZIP</option>
                <option value="individual">JPEG</option>
            </select>
        </div>
    </footer>

    <script>
        const videoInput = document.getElementById('video-input');
        const videoPlayer = document.getElementById('video-player');
        const videoCanvas = document.getElementById('video-canvas');
        // Reverted to default context options, ensuring no explicit alpha
        const canvasCtx = videoCanvas.getContext('2d', { willReadFrequently: true });
        const uploadSection = document.getElementById('upload-section');
        const videoArea = document.getElementById('video-area');
        const controlsSection = document.getElementById('controls-section');
        const extractedFramesSection = document.getElementById('extracted-frames-section');
        const extractedFramesContainer = document.getElementById('extracted-frames-container');
        const timelineCurrentTimeLabel = document.getElementById('timeline-current-time');
        const timelineTotalFramesLabel = document.getElementById('timeline-total-frames');
        const captureFrameBtn = document.getElementById('capture-frame-btn');
        const dialRotatable = document.getElementById('dial-rotatable');
        const timelineScrubber = document.getElementById('timeline-scrubber');
        const timelineLoading = document.getElementById('timeline-loading');
        const dialContainerWrapper = document.getElementById('dial-container-wrapper');

        // New Elements for Footer Controls (Updated to select elements)
        const downloadFooter = document.getElementById('download-footer');
        const mainDownloadBtn = document.getElementById('main-download-btn');
        const scopeSelect = document.getElementById('scope-select'); // Changed from scopeToggle
        const formatSelect = document.getElementById('format-select'); // Changed from formatToggle
        const downloadCountSpan = document.getElementById('download-count'); // New: for the count inside the button
        const selectAllBtn = document.getElementById('select-all-btn'); // New: Select/Deselect All button

        let videoLoaded = false;
        let videoDuration = 0;
        let videoFPS = 30;
        let totalFrames = 0;
        let currentFrameIndex = 0;
        const extractedFrames = []; // Stores captured frames
        let frameIdCounter = 0;
        let timelineThumbnails = [];
        let videoAspectRatio = 16 / 9; // Default to 16:9
        let videoActualWidth = 0; // Store actual video width
        let videoActualHeight = 0; // Store actual video height

        // Download State Toggles (Now read from select values)
        let currentDownloadScope = 'all';
        let currentDownloadFormat = 'zip';

        // Constants for dial sensitivity
        const DIAL_FRAMES_PER_ROTATION = 25;
        const DIAL_DEGREES_PER_FRAME_SENSITIVITY = 360 / DIAL_FRAMES_PER_ROTATION;

        // Utility Functions
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            const milliseconds = Math.floor((remainingSeconds - Math.floor(remainingSeconds)) * 1000);
            // Pad minutes, seconds, and milliseconds with leading zeros if necessary
            return `${String(minutes).padStart(2, '0')}:${String(Math.floor(remainingSeconds)).padStart(2, '0')}.${String(milliseconds).padStart(3, '0')}`;
        }

        // Seeks the video to a specific frame index
        function seekToFrame(frameIndex) {
            if (!videoLoaded || isNaN(frameIndex) || frameIndex < 0 || frameIndex >= totalFrames) return;

            const newTime = frameIndex / videoFPS;
            videoPlayer.currentTime = newTime;
            currentFrameIndex = frameIndex;
            updateTimelineLabels();
            updateDialRotation();
            updateTimelinePosition();
        }

        // Draws the current video frame onto the canvas, maintaining aspect ratio
        function drawFrameToCanvas() {
            if (!videoLoaded || videoPlayer.readyState < 2) return;

            // Use the intrinsic video dimensions for the canvas to avoid black bars
            videoCanvas.width = videoPlayer.videoWidth;
            videoCanvas.height = videoPlayer.videoHeight;

            // Draw the video frame directly to the canvas without scaling or letterboxing
            canvasCtx.drawImage(videoPlayer, 0, 0, videoPlayer.videoWidth, videoPlayer.videoHeight);
        }

        // Updates the time and total frames displayed
        function updateTimelineLabels() {
            timelineCurrentTimeLabel.textContent = `${formatTime(videoPlayer.currentTime)}f`;
            timelineTotalFramesLabel.textContent = `${totalFrames} Frames`;
        }

        // Generates the visual strips on the half dial
        function generateDialStrips() {
            // Preserve the cue, remove old strips
            dialRotatable.innerHTML = ''; // Removed the dial-cue div
            const numStrips = DIAL_FRAMES_PER_ROTATION;
            if (numStrips === 0) return;

            const degreesPerStrip = 360 / numStrips;
            const dialRadius = dialRotatable.offsetWidth / 2;

            for (let i = 0; i < numStrips; i++) {
                const strip = document.createElement('div');
                strip.classList.add('dial-strip');
                const rotation = i * degreesPerStrip;

                strip.style.transformOrigin = `50% ${dialRadius}px`;
                strip.style.transform = `translateX(-50%) rotate(${rotation}deg)`;

                dialRotatable.appendChild(strip);
            }
        }

        // Updates the rotation of the dial based on the current frame index
        function updateDialRotation() {
            if (totalFrames === 0) return;
            const visualDegreesPerFrame = 360 / totalFrames;
            const newRotation = currentFrameIndex * visualDegreesPerFrame;
            dialRotatable.style.transform = `rotate(${newRotation}deg)`;
        }

        // Updates the position and highlights the current thumbnail in the timeline
        function updateTimelinePosition() {
            // Remove highlight from all thumbnails
            document.querySelectorAll('.timeline-thumb').forEach(thumb => {
                thumb.classList.remove('current-thumb');
            });

            let closestThumbElement = null;
            let minFrameDiff = Infinity;

            // Find the thumbnail closest to the current frame
            timelineThumbnails.forEach(thumbData => {
                const frameIndexOfThumb = parseInt(thumbData.element.dataset.frameIndex);
                const diff = Math.abs(currentFrameIndex - frameIndexOfThumb);
                if (diff < minFrameDiff) {
                    minFrameDiff = diff;
                    closestThumbElement = thumbData.element;
                }
            });

            // If a closest thumbnail is found, highlight it and scroll it into view
            if (closestThumbElement) {
                closestThumbElement.classList.add('current-thumb');

                const container = timelineScrubber;
                // Scroll the timeline to center the current thumbnail
                container.scrollLeft = closestThumbElement.offsetLeft - (container.offsetWidth / 2) + (closestThumbElement.offsetWidth / 2);
            }
        }

        // Generates and displays thumbnail previews in the timeline scrubber
        async function generateTimelineThumbnails() {
            timelineScrubber.innerHTML = ''; // Clear existing thumbnails
            timelineThumbnails = [];
            timelineLoading.classList.remove('hidden'); // Show loading indicator

            if (totalFrames === 0) {
                timelineLoading.classList.add('hidden');
                return;
            }

            const targetThumbnails = 100; // Aim for about 100 thumbnails
            const interval = videoDuration / targetThumbnails;

            // Store original video state to restore later
            const originalTime = videoPlayer.currentTime;
            const originalPaused = videoPlayer.paused;
            videoPlayer.pause();

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true }); // No alpha for thumbnails for consistency

            const targetHeight = 42;
            let thumbWidth = 0;
            let thumbHeight = targetHeight;

            // Calculate thumbnail width based on video aspect ratio
            if (videoPlayer.videoWidth > 0 && videoPlayer.videoHeight > 0) {
                const aspectRatio = videoPlayer.videoWidth / videoPlayer.videoHeight;
                thumbWidth = targetHeight * aspectRatio;
            } else {
                thumbWidth = 48; // Default if video dimensions aren't available yet
            }

            tempCanvas.width = thumbWidth;
            tempCanvas.height = thumbHeight;

            // Loop through frames to generate thumbnails
            for (let i = 0; i < totalFrames; i += Math.round(videoFPS * interval)) {
                const time = i / videoFPS;
                const frameIndex = i;

                videoPlayer.currentTime = time;

                // Wait for the video to seek to the new time
                await new Promise(resolve => {
                    videoPlayer.addEventListener('seeked', resolve, { once: true });
                });

                // Ensure thumbnail background is black
                tempCtx.fillStyle = 'black';
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                tempCtx.drawImage(videoPlayer, 0, 0, tempCanvas.width, tempCanvas.height);

                const thumbUrl = tempCanvas.toDataURL('image/jpeg', 0.8); // Get image data as JPEG

                // Create thumbnail element
                const thumb = document.createElement('div');
                thumb.classList.add('timeline-thumb');
                thumb.dataset.frameIndex = frameIndex;
                thumb.style.width = `${thumbWidth}px`;
                thumb.style.height = `${thumbHeight}px`;

                const img = document.createElement('img');
                img.src = thumbUrl;
                img.alt = `Frame at ${formatTime(time)}`;

                thumb.appendChild(img);
                timelineScrubber.appendChild(thumb);

                timelineThumbnails.push({ element: thumb, frameIndex: frameIndex });

                // Add click listener to seek to frame
                thumb.addEventListener('click', () => {
                    seekToFrame(parseInt(thumb.dataset.frameIndex));
                });
            }

            // Restore original video state
            videoPlayer.currentTime = originalTime;
            if (!originalPaused) {
                videoPlayer.play();
            }

            timelineLoading.classList.add('hidden'); // Hide loading indicator
            updateTimelinePosition(); // Update timeline highlight
        }

        // Event Handlers

        // Handles video file selection
        videoInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file && file.type.startsWith('video/')) {
                const videoURL = URL.createObjectURL(file);
                videoPlayer.src = videoURL;
                videoPlayer.load(); // Load the video
                uploadSection.classList.add('hidden'); // Hide upload section
                videoArea.classList.remove('hidden'); // Show video area
                controlsSection.classList.remove('hidden'); // Show controls
                extractedFramesSection.classList.remove('hidden'); // Show frames section initially (empty)
                captureFrameBtn.disabled = true; // Disable capture button until video metadata loads

                updateDownloadButtonStates(); // Set initial footer state
                timelineCurrentTimeLabel.textContent = 'Loading...';
                timelineTotalFramesLabel.textContent = '';
                extractedFrames.length = 0; // Clear previous frames
                renderExtractedFrames(); // Render empty container
            } else {
                console.error('Please select a valid video file.');
            }
        });

        // Handles video metadata loading (duration, dimensions, etc.)
        videoPlayer.addEventListener('loadedmetadata', () => {
            videoLoaded = true;
            videoDuration = videoPlayer.duration;
            videoFPS = 30; // Assuming 30 FPS for calculations
            totalFrames = Math.floor(videoDuration * videoFPS);
            currentFrameIndex = 0;
            videoPlayer.currentTime = 0;

            videoActualWidth = videoPlayer.videoWidth;
            videoActualHeight = videoPlayer.videoHeight;
            videoAspectRatio = videoActualWidth / videoActualHeight;

            // Set CSS variable for aspect ratio (though not directly used in this code for sizing, good practice)
            document.documentElement.style.setProperty('--video-aspect-ratio', videoAspectRatio);

            drawFrameToCanvas(); // Draw the first frame at actual video dimensions
            updateTimelineLabels();
            generateDialStrips();
            updateDialRotation();

            captureFrameBtn.disabled = false; // Enable capture button
            generateTimelineThumbnails();
            updateDownloadButtonStates(); // Update after video load
        });

        // Re-draws canvas and updates UI after video seek
        videoPlayer.addEventListener('seeked', () => {
            drawFrameToCanvas();
            updateTimelineLabels();
            updateDialRotation();
            updateTimelinePosition();
        });

        // Re-draws canvas on video resize (this might need to be removed or adjusted if canvas always matches intrinsic size)
        videoPlayer.addEventListener('resize', () => {
            if (videoLoaded) {
                // When the video player itself resizes, the canvas for display needs to resize
                // The actual extraction canvas should always be videoActualWidth/Height
                drawFrameToCanvas(); // This now draws to the native resolution canvas
            }
        });


        // Handles frame capture button click
        captureFrameBtn.addEventListener('click', async () => {
            if (!videoLoaded) return;

            // Ensure video frame is drawn before capturing
            await new Promise(resolve => {
                videoPlayer.addEventListener('seeked', function onSeeked() {
                    videoPlayer.removeEventListener('seeked', onSeeked);
                    resolve();
                });
                videoPlayer.currentTime = videoPlayer.currentTime; // Trigger a seeked event if already at current time
            });

            // Capture the frame using the intrinsic video dimensions
            const captureCanvas = document.createElement('canvas');
            const captureCtx = captureCanvas.getContext('2d');
            captureCanvas.width = videoActualWidth;
            captureCanvas.height = videoActualHeight;
            captureCtx.drawImage(videoPlayer, 0, 0, videoActualWidth, videoActualHeight);

            // Use 'image/jpeg' for downloaded images by default for solid background, or 'image/png' if user specifically requests transparency.
            const dataURL = captureCanvas.toDataURL('image/jpeg', 1.0); // Use JPEG for opaque output at 100% quality

            extractedFrames.push({
                id: frameIdCounter++,
                frameIndex: currentFrameIndex,
                time: videoPlayer.currentTime,
                dataURL: dataURL,
                selected: true // New frames are automatically selected
            });
            renderExtractedFrames(); // Re-render the extracted frames
            updateDownloadButtonStates(); // Update footer state after capture
        });

        // Renders all extracted frames into the container
        function renderExtractedFrames() {
            extractedFramesContainer.innerHTML = ''; // Clear existing frames
            if (extractedFrames.length === 0) {
                extractedFramesContainer.innerHTML = '<p class="text-gray-400 text-center col-span-full py-8">No frames selected yet. Capture one!</p>';
                // Disable select all button if no frames
                selectAllBtn.disabled = true;
                selectAllBtn.textContent = 'Select All'; // Reset text
                updateDownloadButtonStates(); // Re-check states if frames become 0
                return;
            }
            selectAllBtn.disabled = false; // Enable select all button if frames exist

            // Determine if all frames are currently selected
            const allSelected = extractedFrames.every(frame => frame.selected);
            selectAllBtn.textContent = allSelected ? 'Deselect All' : 'Select All';

            extractedFrames.forEach((frame) => {
                const frameDiv = document.createElement('div');
                frameDiv.id = `frame-${frame.id}`;
                frameDiv.classList.add('extracted-frame', 'relative', 'rounded-md', 'overflow-hidden', 'shadow-md', 'group', 'cursor-pointer');
                // Set aspect ratio dynamically using padding-bottom trick
                frameDiv.style.paddingBottom = `${(1 / videoAspectRatio) * 100}%`;
                frameDiv.style.height = '0'; // Essential for padding-bottom trick

                if (frame.selected) {
                    frameDiv.classList.add('selected'); // This class triggers the border animation and now the button visibility
                }

                const img = document.createElement('img');
                img.src = frame.dataURL;
                img.alt = `Frame ${frame.frameIndex}`;
                img.classList.add('w-full', 'h-full', 'object-cover', 'absolute', 'top-0', 'left-0'); // Added absolute positioning

                const overlay = document.createElement('div');
                overlay.classList.add('absolute', 'inset-0', 'bg-black', 'bg-opacity-50', 'flex', 'flex-col', 'justify-center', 'items-center', 'opacity-0', 'group-hover:opacity-100', 'transition-opacity');

                const timeLabel = document.createElement('span');
                timeLabel.classList.add('text-white', 'text-sm', 'font-semibold', 'mb-2');
                timeLabel.textContent = formatTime(frame.time);

                // --- MODIFIED: Remove button HTML structure and classes ---
                const removeButton = document.createElement('button');
                removeButton.classList.add('remove-button'); // Use custom class for styling
                removeButton.innerHTML = '&times;'; // Larger 'x'
                removeButton.title = 'Remove frame';
                removeButton.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent toggling selection when removing
                    removeFrame(frame.id);
                });
                // --- END MODIFIED ---

                frameDiv.addEventListener('click', () => {
                    toggleFrameSelection(frame.id);
                });

                overlay.appendChild(timeLabel);
                frameDiv.appendChild(img);
                frameDiv.appendChild(overlay);
                frameDiv.appendChild(removeButton); // Append the modified button
                extractedFramesContainer.appendChild(frameDiv);
            });

            updateDownloadButtonStates(); // Update footer button states after rendering frames
        }

        // Removes a frame by its ID
        function removeFrame(id) {
            const index = extractedFrames.findIndex(f => f.id === id);
            if (index > -1) {
                extractedFrames.splice(index, 1);
                renderExtractedFrames(); // Re-render frames after removal
            }
        }

        // Toggles selection state of a frame by its ID
        function toggleFrameSelection(id) {
            const frame = extractedFrames.find(f => f.id === id);
            if (frame) {
                frame.selected = !frame.selected;
                // Re-render the frames to ensure all classes are applied correctly
                renderExtractedFrames();
            }
        }

        // Selects all extracted frames
        function selectAllFrames() {
            extractedFrames.forEach(frame => frame.selected = true);
            renderExtractedFrames();
        }

        // Deselects all extracted frames
        function deselectAllFrames() {
            extractedFrames.forEach(frame => frame.selected = false);
            renderExtractedFrames();
        }
        
        function updateDownloadButtonStates() {
            const selectedCount = extractedFrames.filter(f => f.selected).length;
            const totalCount = extractedFrames.length;

            // Get current values from select elements
            currentDownloadScope = scopeSelect.value;
            currentDownloadFormat = formatSelect.value;

            // Determine if main download button should be disabled
            let isDisabled = false;
            if (totalCount === 0) {
                isDisabled = true; // Always disable if no frames
            } else if (currentDownloadScope === 'selected' && selectedCount === 0) {
                isDisabled = true; // Disable if 'selected' is chosen but nothing is selected
            }
            mainDownloadBtn.disabled = isDisabled;

            // Update main button text based on current selection
            let countText = '';
            if (currentDownloadScope === 'all') {
                countText = `(${totalCount})`;
            } else { // currentDownloadScope === 'selected'
                countText = `(${selectedCount})`;
            }
            downloadCountSpan.textContent = countText; // Set count in the separate span

            if (isDisabled) {
                mainDownloadBtn.querySelector('span').textContent = 'Download'; // Target the span with "Download"
            } else {
                mainDownloadBtn.querySelector('span').textContent = 'Download';
            }
        }

        // Event listener for scope dropdown change
        scopeSelect.addEventListener('change', () => {
            updateDownloadButtonStates();
        });

        // Event listener for format dropdown change
        formatSelect.addEventListener('change', () => {
            updateDownloadButtonStates();
        });

        // Event listener for Select/Deselect All button
        selectAllBtn.addEventListener('click', () => {
            const allSelected = extractedFrames.every(frame => frame.selected);
            if (allSelected) {
                deselectAllFrames();
            } else {
                selectAllFrames();
            }
        });

        // Main Download Button Click Handler
        mainDownloadBtn.addEventListener('click', async () => {
            mainDownloadBtn.disabled = true; // Disable during download
            mainDownloadBtn.querySelector('span').textContent = 'Preparing...'; // Target the main "Download" span
            downloadCountSpan.textContent = ''; // Clear count during preparation

            const framesToDownload = currentDownloadScope === 'all' ? extractedFrames : extractedFrames.filter(f => f.selected);

            if (framesToDownload.length === 0) {
                console.warn('No frames to download.');
                updateDownloadButtonStates();
                return;
            }

            // Determine the file extension based on the selected format
            let fileExtension = 'jpeg'; // Default to JPEG now

            if (currentDownloadFormat === 'zip') {
                const zip = new JSZip();
                framesToDownload.forEach(frame => {
                    // Extract base64 data and create a filename
                    const base64Data = frame.dataURL.split(',')[1];
                    const filename = `frame_${frame.frameIndex}_${formatTime(frame.time).replace(/[:.]/g, '-')}.${fileExtension}`;
                    zip.file(filename, base64Data, { base64: true });
                });

                try {
                    const content = await zip.generateAsync({ type: "blob" });
                    saveAs(content, "extracted_frames.zip");
                } catch (error) {
                    console.error('Error generating ZIP file:', error);
                    mainDownloadBtn.querySelector('span').textContent = 'Download Error';
                } finally {
                    setTimeout(updateDownloadButtonStates, 1500); // Re-enable and update text after download (or error)
                }
            } else { // Individual Files (JPEG)
                try {
                    for (const frame of framesToDownload) {
                        const filename = `frame_${frame.frameIndex}_${formatTime(frame.time).replace(/[:.]/g, '-')}.${fileExtension}`;
                        const blob = await fetch(frame.dataURL).then(res => res.blob());
                        saveAs(blob, filename);
                        await new Promise(resolve => setTimeout(resolve, 100)); // Small delay to prevent browser overload
                    }
                } catch (error) {
                    console.error('Error downloading individual files:', error);
                    mainDownloadBtn.querySelector('span').textContent = 'Download Error';
                } finally {
                    setTimeout(updateDownloadButtonStates, 1500); // Re-enable and update text after download (or error)
                }
            }
        });

        // Dial Interaction Logic
        let isDialDragging = false;
        let initialMouseAngle = 0;
        let lastMouseAngleDuringDrag = 0;
        let accumulatedDragAngle = 0;
        let initialFrameIndexOnDragStart = 0;

        // Add event listeners for starting dial drag (mouse and touch)
        dialContainerWrapper.addEventListener('mousedown', startDialDrag);
        dialContainerWrapper.addEventListener('touchstart', startDialDrag, { passive: false });

        function startDialDrag(event) {
            if (!videoLoaded) return;
            isDialDragging = true;
            dialContainerWrapper.style.cursor = 'grabbing';
            dialRotatable.style.transition = 'none'; // Disable transition during drag

            const rect = dialRotatable.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            // Get client coordinates (handling both mouse and touch events)
            const clientX = event.clientX || (event.touches ? event.touches[0].clientX : 0);
            const clientY = event.clientY || (event.touches ? event.touches[0].clientY : 0);

            // Calculate initial angle from center to mouse/touch point
            initialMouseAngle = Math.atan2(clientY - centerY, clientX - centerX) * (180 / Math.PI);
            lastMouseAngleDuringDrag = initialMouseAngle;
            accumulatedDragAngle = 0;
            initialFrameIndexOnDragStart = currentFrameIndex;

            // Add global event listeners for dragging and ending
            document.addEventListener('mousemove', dragDial);
            document.addEventListener('touchmove', dragDial, { passive: false });
            document.addEventListener('mouseup', endDialDrag);
            document.addEventListener('touchend', endDialDrag);
        }

        function dragDial(event) {
            if (!isDialDragging) return;
            event.preventDefault(); // Prevent default scrolling/panning

            const rect = dialRotatable.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const clientX = event.clientX || (event.touches ? event.touches[0].clientX : 0);
            const clientY = event.clientY || (event.touches ? event.touches[0].clientY : 0);

            const currentMouseAngle = Math.atan2(clientY - centerY, clientX - centerX) * (180 / Math.PI);
            let angleChange = currentMouseAngle - lastMouseAngleDuringDrag;

            // Normalize angle change to be between -180 and 180 degrees
            if (angleChange > 180) angleChange -= 360;
            if (angleChange < -180) angleChange += 360;

            accumulatedDragAngle += angleChange;
            lastMouseAngleDuringDrag = currentMouseAngle;

            // Calculate frame delta based on dial sensitivity
            const frameDelta = Math.round(accumulatedDragAngle / DIAL_DEGREES_PER_FRAME_SENSITIVITY);
            let newFrameIndex = initialFrameIndexOnDragStart + frameDelta;

            // Clamp frame index within valid range
            newFrameIndex = Math.min(Math.max(0, newFrameIndex), totalFrames - 1);

            // Only seek if the frame index has actually changed
            if (currentFrameIndex !== newFrameIndex) {
                 seekToFrame(newFrameIndex);
            }

            updateDialRotation();
        }

        function endDialDrag() {
            isDialDragging = false;
            dialContainerWrapper.style.cursor = 'grab';
            dialRotatable.style.transition = 'transform 0.05s ease-out'; // Re-enable transition
            updateDialRotation();

            // Remove global event listeners
            document.removeEventListener('mousemove', dragDial);
            document.removeEventListener('touchmove', dragDial);
            document.removeEventListener('mouseup', endDialDrag);
            document.removeEventListener('touchend', endDialDrag);
        }

        // Initial setup and resize handling
        window.addEventListener('resize', () => {
            if (videoLoaded) {
                // The main videoCanvas needs to resize for display purposes if the video player container changes.
                // The actual extraction canvas (used on capture) will use intrinsic dimensions.
                drawFrameToCanvas(); // This now draws to the native resolution canvas
            }
        });

        // Initialize on window load
        window.onload = function() {
            renderExtractedFrames(); // Display initial empty state for extracted frames
            updateDownloadButtonStates(); // Set initial footer state based on default dropdown values
        };
    </script>
</body>
</html>